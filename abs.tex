For my thesis, I implemented a static semantics for Haskell by utilizing the K-Framework. My implementation includes support for the module system of Haskell but not for type classes. There are many layers that had to be implemented in K before type inferencing could be performed. The first part of the implementation is the entire context free syntax of Haskell in K. Since all the syntax is included, any program written in the Haskell extended syntax can be parsed into an abstract syntax tree. However, this includes only the Haskell extended syntax. Programs that include multiple modules can be parsed, but the multiple modules must be written in a single file. This is not official Haskell syntax, but allows for support of importing modules. The multiple modules are then made as nodes in a directed acyclic graph. A directed edge in the graph represents a module importing another module. This graph is used for importing the user defined types from one module into another module. Context sensitive checks and type inferencing is then performed on nodes with no outgoing edges. The program then imports the user defined types into a module that has all child modules already checked and inferenced. All rules of the Haskell type system must take mutual recursion into account. There is repeated layering of inferences. Since the semantics is written in the K-Framework, it is mathematically precise and executable. I utilized the executability of the semantics to test both positive inferences and exceptional inferences. This is part of a larger project to give a formal semantics to Haskell.

Subject Keywords: Haskell; Type-System
