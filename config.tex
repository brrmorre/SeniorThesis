\chapter{Configuration}
K is used for defining a state machine and the K rules define the transition rules for the state machine. The configuration of the state machine is made up of K cells. The K cells contain the syntax data structure representing the code of the example program. They also contain the memory of the state machine. An actual state of the state machine in K is when the cells each have some term inside of them.

The following is the configuration of my Haskell semantics.
\begin{lstlisting}
requires "haskell-syntax.k"

module HASKELL-CONFIGURATION
    imports HASKELL-SYNTAX

    syntax KItem ::= "startImportRecursion"
    syntax KItem ::= callInit(K)
    //syntax KItem ::= initPreModule(K) [function]
    //syntax KItem ::= tChecker(K) [function]

    configuration 
        <T>
            <k> $PGM:ModuleList ~> startImportRecursion </k>
            <tempModule> .K </tempModule>
            <tempCode> .K </tempCode>
\end{lstlisting}

The $<k>$ cell is the cell that computation takes place in.
The abstract syntax tree is initially placed into the $<k>$ cell.
The command
\begin{lstlisting}
$PGM:ModuleList
\end{lstlisting}
means that the parsed tree appears in this cell and the sort that contains all other sorts is ModuleList.

$.K$ means that the cell is initially empty.

tempModule is the name of the current module. tempCode is the current code.

typeIterator is used for creating a fresh type variable for the inference algorithm. It has the current count of how many fresh type variables that were created.

\begin{lstlisting}
            <typeIterator> 1 </typeIterator>
\end{lstlisting}

\section{Alpha}
Alpha is a map of type renamings. So if a user declares

\begin{lstlisting}
data MyBool = TTrue
;type MyBooltwo = MyBool
\end{lstlisting}

Then MyBooltwo is a renaming of MyBool. In tempAlpha, an AObject is made. An AObject is a KItem with two children. One can be thought of as a Key and the other is the Value for a map. So MyBool $->$ MyBooltwo. However, we want to check and reject programs that have multiple renamings, so we cannot use a K Map which has idempotence. However, once we make this check, we can then use a K Map. This is what tempAlphaMap is.

.Map means that the cell starts with an empty map.

\begin{lstlisting}
            <tempAlpha> .K </tempAlpha>
            <tempAlphaMap> .Map </tempAlphaMap>
\end{lstlisting}

\section{Beta}

tempT contains all user defined datatypes. tempT is organized in such a way that makes context sensitive checks easy to perform. tempBeta contains all user defined datatypes organized so that type inference is easy to perform. More is explained in chapter 5.
\begin{lstlisting}
            <tempBeta> .Map </tempBeta>
            <tempT> .K </tempT>
\end{lstlisting}

\subsection{Example}
If the user makes the data type $CusBool$ in module $Simp5$, and declares it with this example...
\begin{lstlisting}
data CusBool = True2 | False2
\end{lstlisting}

Then the corresponding $tempBeta$ should look like this. Note how the monomorphic datatype just has an empty $forAll$.

\begin{lstlisting}
    <tempBeta>
        ModPlusType ( Simp5 , False2 ) |-> forAll ( .Set , CusBool .TyVars )
        ModPlusType ( Simp5 , True2 ) |-> forAll ( .Set , CusBool .TyVars )
    </tempBeta>
\end{lstlisting}

If the user makes the data type CusBool in module Simp5, and declares it with this example...
\begin{lstlisting}
data CusBool a b = True2 a | False2 b
\end{lstlisting}

Then the corresponding tempBeta should look like this.
\begin{lstlisting}
    <tempBeta>
        ModPlusType ( Simp5 , False2 ) |-> forAll ( b , funtype ( b , CusBool a b ) )
        ModPlusType ( Simp5 , True2 ) |-> forAll ( a , funtype ( a , CusBool a b ) )
    </tempBeta>

\end{lstlisting}

\section{Delta}

tempDelta contains the arity of the user defined dataTypes. So if a user defined datatype takes in two parameters, tempDelta will contain the number 2.

\begin{lstlisting}
            <tempDelta> .Map </tempDelta>
\end{lstlisting}

\subsection{Example}
If the user makes the data type $CusBool$ in module $Simp5$, and declares it with this example...
\begin{lstlisting}
data CusBool a b = True2 a | False2 b
\end{lstlisting}

Then the corresponding $tempDelta$ should look like this.

\begin{lstlisting}
<tempDelta>
     ModPlusType ( Simp5 , CusBool ) |-> 2
</tempDelta>
\end{lstlisting}

\section{Import Data Structure}

importTree, recurImportTree, and impTreeVMap contain the data necessary for the directed acyclic graph representing imports.

\begin{lstlisting}
            <importTree> .List </importTree>
            <recurImportTree> .List </recurImportTree>
            <impTreeVMap> .Map </impTreeVMap>
\end{lstlisting}

\section{Modules}

The modules cell contains all modules that were checked and inferred already. Multiplicity means that there can be multiple module cells.

\begin{lstlisting}
            <modules> //static information about a module
                <module multiplicity="*">
                    <moduleName> .K </moduleName>
                    <moduleAlphaStar> .K </moduleAlphaStar>
                    <moduleBetaStar> .K </moduleBetaStar>
                    <moduleImpAlphas> .List </moduleImpAlphas>
                    <moduleImpBetas> .List </moduleImpBetas>
                    <moduleCompCode> .K </moduleCompCode>
                    <moduleTempCode> .K </moduleTempCode>
                    <imports> .Set </imports>
                    <classes> //static information about a module
                        <class multiplicity="*">
                            <className> .K </className>
                        </class>
                    </classes>
                </module>
            </modules>
        </T>

endmodule
\end{lstlisting}