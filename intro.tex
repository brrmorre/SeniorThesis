\chapter{Introduction}
In the first progress report, I will detail what I learned about K and the motivation for specifying languages in K, along with Haskell and the goal of my project.
A current problem with engineered systems is that the design of the system is not proven to be working. The system could be non-functional at design time. The designer may not fully understand the system environment or may have not considered the behavior of the system in rare circumstances. Then once the design is made, there may be bugs introduced by implementing the design incorrectly.
The current way that programs are created is by making a design or a formal specification of the program, implementing it, and testing the program against unit tests or verifying the behavior of the program after the fact.
Formal methods are ways to mathematically prove correctness of a system. Without formal methods, the only way to reason about a system is by testing it against different edge cases.
Within the context of a programming language, one way a programming language can be formally specified is by defining a syntax and semantics for that language.
The operational semantics of a programming language can be thought of as a transition system upon an abstract syntax tree, which is the program itself written in the language, and a state, which is a function from the variables in the tree to the current values of those variables. 
This way, real and complex programs written in natural looking programming languages can be interpreted as strings written in formal languages. Once a programming language is defined in this way, certain properties and behavior of the language and programs written in the language can be proven.
K is a framework for creating the formal specification of a programming language. It then can interpret programs written in the language by running only the rules of the formal operational semantics of the programming language. This allows programs to be ran and analyzed formally. This way the formal specification of the complex programming language can be tested and analyzed with the use of a machine.
A K-configuration defines the memory structure of the programming language, made up of cells. The program state can be thought of as the current values of the K-configuration at a certain point in time.
Grammar can be written in K using the constructor ‘syntax’, and a semantic rule can be written in K using the constructor ‘rule’.
Haskell is a purely functional programming language with strong static typing. Purely functional means that the language only allows the user to make functions whose output is only dependant on the function input. Strong static typing means that before a program is run, a type inference algorithm checks the program and ensures that all functions and function applications are allowed with regards to the types of the inputs and outputs. Static refers to the fact that type inference is performed before the code is ran, and will not run during the runtime of the code. Strong typing refers to the fact that the compiler will not allow the user to perform workarounds like typecasting.
My goal for this project is to write the syntax of Haskell and the type system of Haskell in K.